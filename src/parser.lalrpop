use std::str::FromStr;

use crate::ast::{
    literal::{Literal, parse_string_like}
};


grammar;


Identifier: String = {
    RegexIdentifier => String::from(<>)
}

// =========================================== LITERALS ===========================================

pub Literal: Literal = {
    LiteralInt => Literal::Int(<>),
    LiteralFloat => Literal::Float(<>),
    LiteralBool => Literal::Bool(<>),
    LiteralString => Literal::String(<>),
    LiteralName => Literal::Name(<>)
}


LiteralInt: i32 = {
    r"[+-]?[0-9]+" => i32::from_str(<>).unwrap()
}

LiteralFloat: f32 = {
    <s:r"[+-]?[0-9]+\.[0-9]*"> "f"? => f32::from_str(s).unwrap()
}

LiteralBool: bool = {
    KeywordTrue => true,
    KeywordFalse => false
}

LiteralString: String = {
    r#""([^"'\\]|\\.)*""# => parse_string_like(<>)
}

LiteralName: String = {
    r#"'([^"'\\]|\\.)*'"# => parse_string_like(<>)
}


match {
    // Ignore C-style comments
    r"//[^\n\r]*[\n\r]*" => {},
    r"/\*[^\*]*[^/]*(\*/)[\n\r]*" => {},

    "abstract" => KeywordAbstract,
    "array" => KeywordArray,
    "bool" => KeywordBool,
    "break" => KeywordBreak,
    "case" => KeywordCase,
    "class" => KeywordClass,
    "const" => KeywordConst,
    "continue" => KeywordContinue,
    "default" => KeywordDefault,
    "delete" => KeywordDelete,
    "do" => KeywordDo,
    "editable" => KeywordEditable,
    "else" => KeywordElse,
    "entry" => KeywordEntry,
    "enum" => KeywordEnum,
    "event" => KeywordEvent,
    "exec" => KeywordExec,
    "extends" => KeywordExtends,
    "false" => KeywordFalse,
    "final" => KeywordFinal,
    "float" => KeywordFloat,
    "for" => KeywordFor,
    "function" => KeywordFunction,
    "hint" => KeywordHint,
    "if" => KeywordIf,
    "in" => KeywordIn,
    "int" => KeywordInt,
    "import" => KeywordImport,
    "latent" => KeywordLatent,
    "name" => KeywordName,
    "new" => KeywordNew,
    "NULL" => KeywordNull,
    "optional" => KeywordOptional,
    "out" => KeywordOut,
    "parent" => KeywordParent,
    "private" => KeywordPrivate,
    "protected" => KeywordProtected, 
    "public" => KeywordPublic,
    "return" => KeywordReturn,
    "saved" => KeywordSaved,
    "state" => KeywordState,
    "statemachine" => KeywordStatemachine,
    "string" => KeywordString,
    "struct" => KeywordStruct,
    "super" => KeywordSuper,
    "switch" => KeywordSwitch,
    "this" => KeywordThis,
    "timer" => KeywordTimer,
    "true" => KeywordTrue,
    "var" => KeywordVar,
    "virtual_parent" => KeywordVirtualParent,
    "void" => KeywordVoid,
    "while" => KeywordWhile,
} else {
    r"[_a-zA-Z][_a-zA-Z0-9]*" => RegexIdentifier,

    _
}