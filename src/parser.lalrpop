use std::{
    rc::Rc,
    str::FromStr
};

use crate::ast::{
    expression::*,
    literal::*,
    operators::*
};


grammar;


// ========================================= EXPRESSIONS ==========================================

// pub Expression: Rc<Expression> = {
//     "!" <l:Expression> => Rc::new(Expression::UnaryOperation(UnaryOperator::LogicalNot, l)),
//     Term
// };

    // Identifier => Rc::new(Expression::Identifier(<>)),

ExprList: Vec<Rc<Expression>> = Comma<Expr>;

pub Expr: Rc<Expression> = {
    Expr2
};

Expr2: Rc<Expression> = {
    // due to LR(1) restriction, left hand can't be an identifier
    // but as long as we can verify that it yields a type identifier after parsing, we are golden
    "(" <t:Expr2> ")" <e:Expr1> => Rc::new(Expression::TypeCast { target_type: t, expr: e }),
    Expr1
};

Expr1: Rc<Expression> = {
    Identifier => Rc::new(Expression::Identifier(<>)),
    <f:Expr1> "(" <args:ExprList> ")" => Rc::new(Expression::FunctionCall { func: f, args: args }),
    <e:Expr1> "[" <i:Expr> "]" => Rc::new(Expression::Subscript { expr: e, index: i }),
    Expr0
};

Expr0: Rc<Expression> = {
    Literal => Rc::new(Expression::Literal(<>)),
    "(" <Expr> ")" =>  Rc::new(Expression::Nested(<>)),
};


pub IdentifierList: Vec<String> = Comma<Identifier>;

Identifier: String = RegexIdentifier => String::from(<>);


// =========================================== LITERALS ===========================================

pub Literal: Literal = {
    LiteralInt => Literal::Int(<>),
    LiteralFloat => Literal::Float(<>),
    LiteralBool => Literal::Bool(<>),
    LiteralString => Literal::String(<>),
    LiteralName => Literal::Name(<>)
}


LiteralInt: i32 = {
    r"[+-]?[0-9]+" => i32::from_str(<>).unwrap()
}

LiteralFloat: f32 = {
    <s:r"[+-]?[0-9]+\.[0-9]*"> "f"? => f32::from_str(s).unwrap()
}

LiteralBool: bool = {
    KeywordTrue => true,
    KeywordFalse => false
}

LiteralString: String = {
    r#""([^"'\\]|\\.)*""# => parse_string_like(<>)
}

LiteralName: String = {
    r#"'([^"'\\]|\\.)*'"# => parse_string_like(<>)
}


// ============================================ MACROS ============================================

Comma<T>: Vec<T> = {
    <e:T?> <mut ev:("," <T> )*> => {
        if let Some(e) = e {
            ev.insert(0, e);
        }
        ev
    }
};


// ============================= KEYWORDS, SPECIAL TERMINALS & PRECEDENSE =========================

match {
    // Ignore C-style comments
    r"//[^\n\r]*[\n\r]*" => {},
    r"/\*[^\*]*[^/]*(\*/)[\n\r]*" => {},

    "abstract" => KeywordAbstract,
    "array" => KeywordArray,
    "bool" => KeywordBool,
    "break" => KeywordBreak,
    "case" => KeywordCase,
    "class" => KeywordClass,
    "const" => KeywordConst,
    "continue" => KeywordContinue,
    "default" => KeywordDefault,
    "delete" => KeywordDelete,
    "do" => KeywordDo,
    "editable" => KeywordEditable,
    "else" => KeywordElse,
    "entry" => KeywordEntry,
    "enum" => KeywordEnum,
    "event" => KeywordEvent,
    "exec" => KeywordExec,
    "extends" => KeywordExtends,
    "false" => KeywordFalse,
    "final" => KeywordFinal,
    "float" => KeywordFloat,
    "for" => KeywordFor,
    "function" => KeywordFunction,
    "hint" => KeywordHint,
    "if" => KeywordIf,
    "in" => KeywordIn,
    "int" => KeywordInt,
    "import" => KeywordImport,
    "latent" => KeywordLatent,
    "name" => KeywordName,
    "new" => KeywordNew,
    "NULL" => KeywordNull,
    "optional" => KeywordOptional,
    "out" => KeywordOut,
    "parent" => KeywordParent,
    "private" => KeywordPrivate,
    "protected" => KeywordProtected, 
    "public" => KeywordPublic,
    "return" => KeywordReturn,
    "saved" => KeywordSaved,
    "state" => KeywordState,
    "statemachine" => KeywordStatemachine,
    "string" => KeywordString,
    "struct" => KeywordStruct,
    "super" => KeywordSuper,
    "switch" => KeywordSwitch,
    "this" => KeywordThis,
    "timer" => KeywordTimer,
    "true" => KeywordTrue,
    "var" => KeywordVar,
    "virtual_parent" => KeywordVirtualParent,
    "void" => KeywordVoid,
    "while" => KeywordWhile,
} else {
    r"[_a-zA-Z][_a-zA-Z0-9]*" => RegexIdentifier,

    // ignore whitespace
    r"\s*" => {},

    _
}